const {
  http
} = require('../http.js')
const {
  writeLine
} = require('../utils/fswrite.js')
const {
  getCandles
} = require('./getCandles.js')
const fs = require('fs')
let gap = 15
let startTime = '2021-03-01 00:00:00'
let endTime = '2021-03-31 00:00:00'
let coin = 'EOS-PERP'
// getCandles(startTime, endTime, coin, gap)
// return

// 初始金钱
let nowMoney = 1
// 止盈和止损点
let losePoint = 0.02
let winPoint = 0.02
// 插针与实体的倍数
let openGap = 2
// 当前开单的最大盈利值
let maxWin = 0
// 是否开始回撤关单
let openGoBack = false
// 多少利润开始计算回撤
let goBackNum = 0.02
// 回撤到多少时止盈
let goBackTime = 0.8
// 是否需要检查当前趋势
let needTestTrend = true
// 某一阶段蜡烛图
let Candles15 = JSON.parse(fs.readFileSync(`./${coin}-${startTime}-${endTime}-${gap}.txt`, 'utf-8'))
let Candles1 = JSON.parse(fs.readFileSync(`./${coin}-${startTime}-${endTime}-1.txt`, 'utf-8'))

// 开单记录
let orders = {
  upWin: 0,
  upFail: 0,
  downWin: 0,
  downFail: 0,
  // 连续失败次数记录
  continuosFail: [],
  failCounts: 0
}

findOpenPoint(Candles15, 0)
// 寻找开单点
function findOpenPoint(allCandles, startIndex) {
  if (startIndex !== -1) {
    for (let index = startIndex; index < allCandles.length; index++) {
      const candle = allCandles[index];
      let flag = testOpen(candle, index)
      // flag = 'up'
      if (flag) {
        // 因为添加了确认线的判断，所以这里还需要再加一个index
        index++
        // 开单点应该是符合条件后的一条
        openMarket(index + 1, flag)
        return index
      }
    }
  }
  // 因为可能最后几次连续止损，没有计算的机会
  if (orders.failCounts) orders.continuosFail.push(orders.failCounts)
  console.log('总览：', orders);
}

function openMarket(index, flag) {
  maxWin = 0
  let candle = Candles15[index]
  if (!candle) return
  let openTime = candle.time
  let openPrice = Candles15[index].open
  // 开单点
  let start1index = Candles1.findIndex(c => {
    return c.time === openTime
  })
  // 寻找平单点
  let close1index = testClose(openPrice, start1index, flag)
  console.log('本单最大盈利值：', maxWin);
  console.log('当前资金:', nowMoney);
  console.log('-------------------------');
  // return
  // 寻找下一个测试开单的点
  let nextPoint = findNextTestOpenPoint(close1index)
  findOpenPoint(Candles15, nextPoint)
}
// 开单策略
function testOpen(candle, index) {
  let {
    time,
    open,
    high,
    low,
    close,
    volume
  } = candle;
  // 上影，下影，实体
  let highNeedle, lowNeedle, substance
  if (open - close > 0) {
    // 如果是跌的话那么实体的上影应该是 最高价减去开盘价 (high - open)
    highNeedle = high - open;
    lowNeedle = close - low;
    substance = open - close;
  } else {
    // 如果是涨的话那么实体的上影应该是 最高价减去收盘价 (high - close)
    highNeedle = high - close;
    lowNeedle = open - low;
    substance = close - open;
  }
  // 波动值，如果波动太小，则没有意义
  let wavePercent = (high - low) / low * 100;
  // 波动值BTC可以小一点，其他的要达到1%
  if (wavePercent < 1) {
    return
    if (item == 'BTC' && wavePercent > 0.5) {
      // btc的波动可以小一点去操作，后期可以根据不同币种设置阈值
    } else {
      console.log(`${item}的波动值${wavePercent}%，波动太小，没有意义`);
      return;
    }
  }

  if (highNeedle / substance > openGap && lowNeedle / substance > openGap) {
    // 上下都超openGap倍，十字针先不管吧
    return false
  } else if (highNeedle / substance > openGap) {
    // 开空必须是在上涨趋势中，上涨无力了再开空
    if (!testTrend('up', index)) return false;
    // 上长针 - 上涨无力 - 开空
    console.log('open down time', new Date(time).toLocaleString());
    console.log('open down price', close);
    return 'down'
  } else if (lowNeedle / substance > openGap) {
    // 开多必须是在下降趋势中，下降无力了再开多
    if (!testTrend('down', index)) return false;
    // 下长针 - 下跌无力 - 开多
    console.log('open up time', new Date(time).toLocaleString());
    console.log('open up price', close);
    return 'up'
  } else {
    return false
  }
}
// 平单策略
function testClose(openPrice, start1index, flag) {
  for (let i = start1index; i < Candles1.length; i++) {
    const c = Candles1[i];
    let priceDiff = ((c.close - openPrice) / openPrice).toFixed(3)
    if (flag === 'up') {
      // 如果当前盈利大于最大盈利，那么替换最大盈利值
      if (priceDiff > 0 && priceDiff > maxWin) maxWin = priceDiff
      // 利润大于回撤阈值过后，回撤一半就关单，防止拖单下去方向错了最后触发止损
      let shouldClose = openGoBack && maxWin > goBackNum && priceDiff > 0 && priceDiff < (maxWin * goBackTime)
      // 如果是多单
      if (priceDiff > winPoint || shouldClose) {
        //止盈
        console.log('多单止盈');
        console.log('本单利润：', priceDiff);
        console.log('close up time', new Date(c.time).toLocaleString());
        console.log('close up price', c.close);
        orders.upWin++
        orders.continuosFail.push(orders.failCounts)
        orders.continuosFail = 0
        nowMoney = nowMoney + nowMoney * priceDiff
        return i
      } else if (priceDiff < -losePoint) {
        console.log('多单止损');
        console.log('close up time', new Date(c.time).toLocaleString());
        console.log('close up price', c.close);
        orders.upFail++
        orders.continuosFail++
        nowMoney = nowMoney + nowMoney * priceDiff
        // 止损
        return i
      }
    } else if (flag === 'down') {
      // 如果当前盈利大于最大盈利，那么替换最大盈利值
      // console.log(new Date(c.time).toLocaleString(), priceDiff);
      // console.log(priceDiff < 0);
      // console.log(Math.abs(priceDiff) > Math.abs(maxWin));
      // console.log(priceDiff, maxWin);
      if (priceDiff < 0 && Math.abs(priceDiff) > Math.abs(maxWin)) {
        // console.log('替换maxWin');
        maxWin = priceDiff
      }
      let shouldClose = openGoBack && maxWin < -goBackNum && priceDiff < 0 && Math.abs(priceDiff) < Math.abs((maxWin * goBackTime))
      // 空单
      if (priceDiff < -winPoint || shouldClose) {
        //止盈

        console.log('空单止盈');
        console.log('本单利润：', priceDiff);
        console.log('close down time', new Date(c.time).toLocaleString());
        console.log('close down price', c.close);
        orders.downWin++
        orders.continuosFail.push(orders.failCounts)
        orders.failCounts = 0
        nowMoney = nowMoney - nowMoney * priceDiff
        return i
      } else if (priceDiff > losePoint) {
        console.log('空单止损');
        console.log('close down time', new Date(c.time).toLocaleString());
        console.log('close down price', c.close);
        orders.downFail++
        orders.failCounts++
        nowMoney = nowMoney - nowMoney * priceDiff
        // 止损
        return i
      }
    }
  }
}

// 寻找下一个开始测试开单点的时间节点
function findNextTestOpenPoint(close1index) {
  return Candles15.findIndex(c => {
    return c && Candles1[close1index] && c.time > Candles1[close1index].time
  })
}

// 检测当前趋势
function testTrend(direction, index) {
  if (!needTestTrend) return true
  let thisCandle = Candles15[index]
  // 下一段必须是一个反转的确认线
  let next1 = Candles15[index + 1]
  if (direction === 'up') {
    // 如果是检查上升趋势中，那么下一根线一定要是下跌的确认线，才说明开始反转了
    // 并且下一根线的最低价要低于这一根线的
    // 如果不满足这两个条件，那么返回false
    if (next1.close > next1.open || next1.low > thisCandle.low) {
      return false
    }
  }
  if (direction === 'down') {
    // 如果是检查下降趋势中，那么下一根线一定要是上涨的确认线，才说明开始反转了
    // 并且下一根线的最高价要超过这一根线的
    // 如果不满足这两个条件，那么返回false
    if (next1.close < next1.open || next1.high > thisCandle.high) {
      return false
    }
  }
  // 定义一个变量，蜡烛上涨一次加一，下降一次减一，当这个变量大于0时说明是上涨趋势
  if (index < 3) return true
  let last3 = Candles15.slice(index - 3, index)
  let flag = 0
  for (let i = 0; i < last3.length; i++) {
    const candle = last3[i];
    if ((candle.close - candle.open) > 0) {
      flag++
    } else {
      flag--
    }
  }
  if (direction == 'up' && flag > 0) return true
  if (direction == 'down' && flag < 0) return true
  return false
}

// getEthCandles()